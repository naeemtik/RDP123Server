name: Expose RDP via ngrok (public, with cleanup)

on:
  workflow_dispatch:

jobs:
  rdp-ngrok:
    runs-on: windows-latest
    timeout-minutes: 180

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Enable RDP and firewall
        shell: powershell
        run: |
          # Enable Remote Desktop and (optionally) disable NLA for compatibility
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 0 -Force
          # Create firewall allow rule for port 3389
          netsh advfirewall firewall delete rule name="RDP-Auto" > $null 2>&1
          netsh advfirewall firewall add rule name="RDP-Auto" dir=in action=allow protocol=TCP localport=3389
          Restart-Service -Name TermService -Force

      - name: Create temporary RDP user (rdpuser)
        id: create_user
        shell: powershell
        run: |
          Add-Type -AssemblyName System.Security
          $chars = @{
            Upper = [char[]](65..90)
            Lower = [char[]](97..122)
            Number = [char[]](48..57)
            Special = ([char[]](33..47) + [char[]](58..64) + [char[]](91..96) + [char[]](123..126))
          }
          $pwdPool = @()
          $pwdPool += $chars.Upper | Get-Random -Count 3
          $pwdPool += $chars.Lower | Get-Random -Count 6
          $pwdPool += $chars.Number | Get-Random -Count 3
          $pwdPool += $chars.Special | Get-Random -Count 2
          $password = -join ($pwdPool | Sort-Object { Get-Random })

          $secure = ConvertTo-SecureString $password -AsPlainText -Force

          if (Get-LocalUser -Name "rdpuser" -ErrorAction SilentlyContinue) {
            # remove existing temporary user to ensure clean state
            Remove-LocalUser -Name "rdpuser" -ErrorAction SilentlyContinue
          }
          New-LocalUser -Name "rdpuser" -Password $secure -AccountNeverExpires -Description "Temporary RDP user for GitHub Actions"
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member "rdpuser"
          # Optional: add to Administrators if you need admin rights
          Add-LocalGroupMember -Group "Administrators" -Member "rdpuser"

          # Export password and username to env for other steps (avoid printing token)
          echo "RDP_USERNAME=rdpuser" >> $env:GITHUB_ENV
          echo "RDP_PASSWORD=$password" >> $env:GITHUB_ENV

      - name: Download and unpack ngrok
        shell: powershell
        run: |
          $zip = "$env:TEMP\ngrok.zip"
          $exe = "$env:RUNNER_TEMP\ngrok.exe"
          Invoke-WebRequest -Uri "https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-windows-amd64.zip" -OutFile $zip
          Expand-Archive -Path $zip -DestinationPath $env:RUNNER_TEMP -Force
          Remove-Item $zip -Force
          if (-not (Test-Path $exe)) {
            Write-Error "ngrok executable not found in $env:RUNNER_TEMP"
            exit 1
          }

      - name: Configure ngrok auth token (from secret)
        shell: powershell
        env:
          NGROK_AUTH_TOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}
        run: |
          if (-not $env:NGROK_AUTH_TOKEN) { Write-Error "Secret NGROK_AUTH_TOKEN is missing. Add it in repo Settings -> Secrets."; exit 1 }
          & "$env:RUNNER_TEMP\ngrok.exe" authtoken $env:NGROK_AUTH_TOKEN

      - name: Start ngrok TCP tunnel (background) and capture PID & public address
        id: start_ngrok
        shell: powershell
        run: |
          $ngrokPath = "$env:RUNNER_TEMP\ngrok.exe"
          # Start ngrok in background (tcp 3389). Keep stdout for logs.
          $proc = Start-Process -FilePath $ngrokPath -ArgumentList "tcp 3389 --log=stdout" -NoNewWindow -PassThru
          # save PID for cleanup
          echo "NGROK_PID=$($proc.Id)" >> $env:GITHUB_ENV

          # Wait for ngrok local API to be ready and fetch tunnels
          $public = $null
          $retries = 0
          while (-not $public -and $retries -lt 20) {
            try {
              $api = Invoke-RestMethod -Uri http://127.0.0.1:4040/api/tunnels -ErrorAction Stop
              $t = $api.tunnels | Where-Object { $_.proto -eq "tcp" } | Select-Object -First 1
              if ($t -and $t.public_url) { $public = $t.public_url }
            } catch { }
            Start-Sleep -Seconds 2
            $retries++
          }
          if (-not $public) { Write-Error "ngrok did not provide a public tcp tunnel (timed out)"; exit 1 }

          # public_url like tcp://0.tcp.ngrok.io:xxxxx -> strip tcp://
          $public_clean = $public -replace "^tcp://",""
          echo "NGROK_PUBLIC=$public_clean" >> $env:GITHUB_ENV
          Write-Host "ngrok public: $public_clean"

      - name: Create .rdp file pointing to ngrok public host:port
        shell: powershell
        run: |
          $rdpPath = "$env:RUNNER_TEMP\github-rdp.rdp"
          $address = "${{ env.NGROK_PUBLIC }}"
          if (-not $address) { Write-Error "NGROK_PUBLIC missing"; exit 1 }
          Set-Content -Path $rdpPath -Value @"
          full address:s:$address
          username:s:$env:RDP_USERNAME
          authentication level:i:0
          enablecredsspsupport:i:0
          "@
          echo "RDP_FILE=$rdpPath" >> $env:GITHUB_ENV

      - name: Upload .rdp artifact
        uses: actions/upload-artifact@v4
        with:
          name: rdp-connection
          path: ${{ env.RDP_FILE }}

      - name: Show connection info in run summary
        shell: powershell
        run: |
          echo "### RDP (public) connection" >> $env:GITHUB_STEP_SUMMARY
          echo "- Address: $env:NGROK_PUBLIC" >> $env:GITHUB_STEP_SUMMARY
          echo "- Username: $env:RDP_USERNAME" >> $env:GITHUB_STEP_SUMMARY
          echo "- Password: $env:RDP_PASSWORD" >> $env:GITHUB_STEP_SUMMARY
          echo "- Download the .rdp from Artifacts -> rdp-connection" >> $env:GITHUB_STEP_SUMMARY
          # also print once in logs for quick copy
          Write-Host "RDP => $env:NGROK_PUBLIC  | $env:RDP_USERNAME : $env:RDP_PASSWORD"

      - name: Keep session alive (run until you cancel the job)
        shell: powershell
        run: |
          Write-Host "`nRDP session active. Cancel the workflow run to close the tunnel and trigger cleanup.`n"
          while ($true) {
            Write-Host "[$(Get-Date -Format o)] running..."
            Start-Sleep -Seconds 60
          }

      - name: Cleanup (always runs)
        if: always()
        shell: powershell
        run: |
          Write-Host "`n-- CLEANUP START --`n"
          # Kill ngrok if started
          if ($env:NGROK_PID) {
            try {
              Stop-Process -Id $env:NGROK_PID -Force -ErrorAction SilentlyContinue
              Write-Host "Stopped ngrok pid $env:NGROK_PID"
            } catch { Write-Warning "Failed to stop ngrok pid $env:NGROK_PID" }
          } else {
            # fallback: stop any ngrok.exe processes
            Get-Process -Name ngrok -ErrorAction SilentlyContinue | ForEach-Object { Stop-Process -Id $_.Id -Force -ErrorAction SilentlyContinue }
            Write-Host "Stopped any remaining ngrok processes (fallback)"
          }

          # Remove temporary user
          if (Get-LocalUser -Name "rdpuser" -ErrorAction SilentlyContinue) {
            try {
              Remove-LocalUser -Name "rdpuser" -ErrorAction SilentlyContinue
              Write-Host "Removed local user rdpuser"
            } catch { Write-Warning "Failed to remove rdpuser (might require elevated permissions)" }
          }

          # Remove firewall rule
          netsh advfirewall firewall delete rule name="RDP-Auto" > $null 2>&1
          Write-Host "`n-- CLEANUP END --`n"
